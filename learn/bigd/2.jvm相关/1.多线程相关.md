# 多线程相关

#### 内存模型

数据读取和写入过程。主存->CPU高速缓存->操作->写入主存

**java的内存模型（JMM）**规定所有变量都存在主存中，每个线程都有自己的工作内存（高速缓存）。线程对变量所有操作都必须在工作内存中进行，而不能直接对主存进行操作。每个线程不能访问其他线程的工作内存。

#### 缓存不一致问题解决方案

* 通过总线加锁机制 给某个共享变量加速，但是效率过低
* 通过缓存一致性协议  发生改变，通过广播，将共享变量的缓存状态设置无效

#### 并发编程中三个概念

* 原子性
* 可见性  —多个线程改变了访问的同一个变量时候，一个线程改变了值，其他线程得立马看到修改的值
* 有序性  — JVM执行代码时候，在不改变输出结果的情况下，会出现指令重排序。但是排序前提是相互不依赖，如果某个指令B依赖某指令A，则肯定会保证指令A在指令B之前执行。

#### java 多线程中的三个特性

##### 原子性

java中基本类型变量读取和赋值操作都是原子性操作，即不可中断。

```java
int i= 1; // 只有这个是原子操作
int x = i;//存在两步，第一步从工作内存读取 i的值，第二步将1写入工作内存
x++;
x =x+1;
```

##### 可见性

提供关键字 **volatile**关键字保证可见性。

当一个共享变量被volatile修饰时，他会保证修改的值会立即被更新到主存，当有其他线程读取时，他会去内存中读取新值。普通共享变量无法保证可见性。

通过synchronized和Lock也可以保证可见性，这两个关键字可以保证同一时刻只有一个线程获取锁并执行同步代码，并且在释放锁的同时将变量修改刷新到主存当中，保证其可见性。

##### 有序性

java内存模型允许编译器和处理器对指令进行重排序，重排序后不会影响单线程执行，但是会影响多线程并发执行正确性。

##### JVM先天有序性—  happens-before原则

* **程序次序原则**：还是只存在单线程模型中，程序可以认为 顺序执行。其实只是执行结果一致而已。
* 锁**定规则**：一个被锁的操作，必然先执行unlock才会执行后一个操作的lock操作。
* **volatile变量规则**： 对一个变量的写操作先于后面对这个变量的读操作
* **传递规则**：
* 线程启动规则 ：thread的start优先线程每一个动作
* 线程中断规则： 线程interrupt()方法调用优先被中断线程检测到中断
* 线程终结规则：线程操作都先于终止
* 对象终结规则： 

##### volatile

一旦共享变量被volatile修饰之后

* 保证不同线程对这个变量操作的可见性
* 禁止了指令重排序
  * 程序执行到volatile变量读写操作时，前面操作更改肯定全部已经执行，结果对后面操作可见；再其后面的操作肯定没有执行
  * 指令优化时，不能将再对volatile变量访问语句放到其后面执行，也不能吧volatile变量后面语句放到其前面执行

