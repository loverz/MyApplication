### MVC MVVM MVP

原生安卓就是一个mvc，View就是xml，C是Activity：弊端就是C承担的事物过承重，Mmodel数据处理层；

MVP抽离解耦之前Act，事件处理和逻辑处理给分开，相当于在act上再构建了一层；

MVVM 有一层 VM V绑定过程，及时响应相关属性变化，界面感知；

### IOC 依赖注入

控制反转和依赖注入，工厂模式，委托给第三方管理新建、销毁对象。只需要提供依赖对象，通过ioc容器动态注入对象供使用。解耦，aop面向切面编程；

### 代理

动态和静态代理，静态相当于全部实现接口来实现代理，委托；动态是通过反射方式，直接代理处理；目的也是为了解耦，帮助代码专一实现功能；

### 范型

extends super关键字，区别是 ? Extends T 表示是T或者是T的子类，super反过来表示父类

### 性能优化

用的比较多的是 systemtrace 用来检测具体耗时，资源；viewtrace可视化看代码耗时；leakcanary

### == equals hashcode

== 地址比较，引用是否相等，重新new一个对象都不等；equals 和hashcode配套使用

### String 不可变对象

设计常量，常量池；经常使用，方便hashcode查找，效率性能考虑；安全考虑

### run start区别

run()是运行在调用此方法当前线程，start是开一个线程进行方法调用；

### 类锁、对象锁、私有锁

类锁针对的是类，对象是针对的对象；分别为 synchronized(A.class)  synchronized(this

### int integer

integer为包装类，会有一个指针引用指向一块内存；int为常量，数值会放到常量池；

### 静态属性和方法继承重写

静态方法属性属于类方法，不是对象，可以直接在子类访问得到，可以认为是可继承；但是不能重写，结合类加载机制，与类相关，没法重写；

### 算法

* 单链表倒序
* 二叉树镜像，t t[left] = tmp;t[left]=t[right];t[right]=tmp;
* 多叉树非递归遍历，借助堆栈实现
* 快排，low high，第一个元素找到对应在数组中的位置；然后切分开两部分进行递归排序；
* 冒泡，循环，第一次先把最大的冒泡到最后
* 堆排序，借助大顶堆来进行排序；构建堆，然后沉底元素；再排序，沉底元素；
* 子串包含问题，
* jvmgc算法：引用计数，标记清楚，新老生代算法
* 找到弟N大的数；使用最小堆，将数据逐步往最小堆里面放，和顶比较，如果比顶大，则替换，排序；
* B树：这个主要是平衡树，每个节点有数据，left、right两个儿子，左比右小；右边比父大；B+树用来做文件数据库索引，会保存父节点数据，叶子节点还包括下叶子节点的地址指针；

## 线程

