# 安卓Native层代码崩溃检测机制
Linux中，so是通过GCC/G++编译，崩溃会产生信号异常。An底层也是linux，所以so崩溃也会出现信号异常，所以如果
需要捕获动态库的异常，就需要捕获这个信号异常。

### 信号机制原理
信号其实是一种软件层面的中断机制，当程序出现错误，就会产生信号事件。linux是由内核管理，内核会接收信号，并将
这个信号放到对应的进程信号队列里面。当进程由于异常，中断进入内核态之后，从内核态变回用户态之前，回检测这个对应
的信号队列，并查询响应信号的处理函数。内核会默认分配一个信号处理函数，如果需要对某个特定的信号处理，就需要注册
对应的处理函数了。

信号异常响应可以分为
* 忽略信号
* 捕获信号
* 默认处理

这里提到一个sigaction()，传入信号ID，act函数指针。用于改变进程接收到信号之后的行为。还可以把后面参数都质NULL
用来检测某个信号id对应的信号有效性。

#### 获取native奔溃堆栈信息
Android so层的奔溃并没有像上层一样提供一个 Throwable.printStackTrace的方法。所以需要处理。有两种方案
##### 1.利用logcat日志来实现
    Process process = Runtime.getRuntime().exec(new String[]{"logcat","-d","-v","threadtime"});
    String logTxt = getSysLogInfo(process.getInputStream());
在获取到有异常信号后，调到我们的异常处理函数，我们通知上层，在java层启动一个新的进程，并且在这个进程上做上面的操作。
（这里注意，必须是新进程，如果原来进程很快就会销毁）

##### 2.Google Breakpad
linux中提供了Core dump机制，及操作系统会吧程序奔溃的内容dump出来，写到一个core文件里面。G B 是一个跨平台的奔溃
堆栈分析模块

### breakpad解析
参考：https://blog.csdn.net/wpc320/article/details/8290501
分为三个组件
* 客户端 它可以获取当前线程的状态和当前加载的可执行文件和共享库的ID写转储文件。
* 符合卸载器 读取由编译器产生的调试信息，并生成一个使用Breakpad格式的符号文件。
* 处理器 是一个程序，读取一个minidump文件，找到相应的版本的符号文件的（可执行文件和共享库的转储提到的），
并产生了一个人可读的C / C + +堆栈跟踪。

### 堆栈信息的分析
提到三种分析工具
* addr2line 用来分析单个pc地址对应的源码行数，比如示例log中的第13行中的#00 pc 0004097c
，0004097c就是crash时pc调用的堆栈地址，用这个地址就可以分析出对应在源码中的行数；
* objdump 用来把相应的so变成汇编语言的asm文件，然后根据地址信息（比如0004097c）就可以找到更加详细的相关函数信息；
* ndk-stack 用来把log信息全部翻译成更加详细的带源码行数信息的log，相当于是在整个crash堆栈信息都执行addr2line命令。

其实就是拿到两个东西，捕获的堆栈信息，还有就是对应程序的so（必须是带symbols,带符号表）
符号表包括（起始地址，结束地址，函数，文件名：行号）