# IO相关学习

## 同步、异步、阻塞、非阻塞

首先明确有五种IO模型
##### 同步模型
* 阻塞IO （blocking io）
* 非阻塞IO （non-blocking io）
* 多路复用IO 使用select/poll select函数来执行循环查询数据状态
* 信号驱动IO
##### 异步模型
* 异步IO A-IO （asynchronous IO）

### 同步异步区别
同步是一个任务需要依赖另外一个任务，必须等待被依赖这个任务完成后，依赖的任务才会执行完成。这个是一个可靠的任务序列。


异步是不需要等到被依赖的那个任务执行完毕，只需要知道被依赖做了啥，就可以立即执行自己的任务，只要自己完成了，
整个任务也就算完成了。

### 阻塞和非阻塞区别
阻塞是值得调用结果返回之前，当前的程序会被挂起，一直处于等待消息通知，不执行其他业务。这两个概念的区别是在数据没有
准备好之前，分别是等待还有就是直接不管结果（阻塞或者不阻塞当前线程），直接进行下一步操作的区别。

### 相关理解
同步异步关注的是消息的通知机制，而阻塞和非阻塞关注的线程或者程序等待消息通知的状态。

同步、异步、阻塞、非阻塞 分三个层次来区分 CPU层次；线程层次；程序员感知层次
##### CPU层次
在CPU层次，操作系统任务调度的层次：大部分都是使用的的异步非阻塞方式进行IO，也就是发出了IO请求之后，并不会等待
IO执行完成，而是直接进行下面的指令（非阻塞），IO操作和cpu指令操作互不干扰（异步），通过中断和回调方式完成结果。
##### 线程层次
或者说是操作系统调度单元层次，操作系统为了减轻程序员的负担，把底层异步非阻塞的IO封装，read、write等以同步的方式展现
出来。然而，同步阻塞的IO是线程挂起，同步非阻塞IO会消耗cpu资源在轮询上。
于是产生了三种思路：
* 多线程（同步阻塞）
* 多路复用
* 直接暴露异步接口，例如异步非阻塞 AIO
##### 程序员感知层次
这里其实就是各个网络框架在做的事情，提供了同步阻塞，异步非阻塞回调的方式来供程序来进行调用。

### 总结
最主要搞清楚同步异步，阻塞非阻塞所指定的环境。同步异步是指的消息或者任务调度方式，例如是采用同步轮训，还是异步回调方式。
而阻塞非阻塞，主要讲的是某一个任务执行之后当前任务的一个状态表示。

